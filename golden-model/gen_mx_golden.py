#!/usr/bin/env python3
"""
Generate MX-encoded golden model output for RedMulE
Takes FP16 GEMM result and encodes to MX format
"""

import sys
import numpy as np
sys.path.insert(0, '/scratch2/msc25h32/redmule/golden-model/MX')
from mx_fp_golden import encode_block_fp16_to_mx

# Read the FP16 golden output that was just generated
inc_path = sys.argv[1] if len(sys.argv) > 1 else '../sw/inc'

# Read dimensions
with open(f'{inc_path}/tensor_dim.h', 'r') as f:
    for line in f:
        if 'M_SIZE' in line:
            m_size = int(line.split()[2])
        elif 'K_SIZE' in line:
            k_size = int(line.split()[2])

print(f"Encoding {m_size}×{k_size} matrix to MX format...")

# Read the FP16 output data (z_output.h or similar)
# For now, let's reconstruct from the existing golden.h
with open(f'{inc_path}/golden.h', 'r') as f:
    content = f.read()
    
# Extract hex values from golden.h
import re
hex_vals = re.findall(r'0x([0-9a-fA-F]+)', content)

# Unpack to FP16 values
fp16_values = []
for hex_val in hex_vals:
    # Each is 32-bit containing 2 FP16 values
    val = int(hex_val, 16)
    fp16_0 = val & 0xFFFF
    fp16_1 = (val >> 16) & 0xFFFF
    fp16_values.extend([fp16_0, fp16_1])

# Trim to actual size
fp16_values = fp16_values[:m_size * k_size]

print(f"Read {len(fp16_values)} FP16 values")

# Encode to MX format in blocks of 32
mx_encoded = []
mx_exponents = []

for i in range(0, len(fp16_values), 32):
    block = fp16_values[i:i+32]
    # Pad if needed
    while len(block) < 32:
        block.append(0)
    
    exp, fp8_vals = encode_block_fp16_to_mx(block)
    mx_encoded.extend(fp8_vals)
    mx_exponents.append(exp)

print(f"Encoded to {len(mx_encoded)} FP8 values in {len(mx_exponents)} blocks")

# Write new golden.h with MX format (4 FP8 values per 32-bit word)
with open(f'{inc_path}/golden.h', 'w') as f:
    f.write(' /* Header file generated by RedMulE Golden Model (MX-encoded) */\n')
    num_words = (len(mx_encoded) + 3) // 4
    f.write(f'uint32_t golden [{num_words}] = {{\n')
    
    for i in range(0, len(mx_encoded), 4):
        vals = mx_encoded[i:i+4]
        while len(vals) < 4:
            vals.append(0)
        # Pack 4 FP8 values into 32-bit word (little-endian)
        word = vals[0] | (vals[1] << 8) | (vals[2] << 16) | (vals[3] << 24)
        f.write(f'0x{word:08x},\n')
    
    f.write("};\n")

# Update tensor_dim.h to indicate MX format
with open(f'{inc_path}/tensor_dim.h', 'r') as f:
    lines = f.readlines()

with open(f'{inc_path}/tensor_dim.h', 'w') as f:
    for line in lines:
        if 'DST_FMT' in line:
            f.write('#define DST_FMT FP8\n')
        elif 'FPFORMAT 16' in line:
            f.write('#define FPFORMAT 8\n')
        else:
            f.write(line)

print(f"✓ Generated MX-encoded golden output in {inc_path}/golden.h")
print(f"✓ Updated {inc_path}/tensor_dim.h to DST_FMT=FP8")
